#ifndef WARBLER_TOKEN_HPP
#define WARBLER_TOKEN_HPP

// local includes
#include <warbler/util/array.hpp>
#include <warbler/util/table.hpp>
#include <warbler/source/snippet.hpp>
#include <warbler/source/location.hpp>

namespace warbler::lexicon
{
	enum TokenType
	{
		TOKEN_END_OF_FILE,
		TOKEN_IDENTIFIER,
		TOKEN_LPAREN,
		TOKEN_RPAREN,
		TOKEN_LBRACK,
		TOKEN_RBRACK,
		TOKEN_LBRACE,
		TOKEN_RBRACE,
		TOKEN_SEMICOLON,
		TOKEN_COLON,
		TOKEN_COMMA,
		TOKEN_DOT,
		TOKEN_ELIPSIS,
		TOKEN_AMPERSAND,
		TOKEN_PIPELINE,
		TOKEN_CARROT,
		TOKEN_LSHIFT,
		TOKEN_RSHIFT,
		TOKEN_BOOLEAN_NOT,
		TOKEN_BOOLEAN_AND,
		TOKEN_BOOLEAN_OR,
		TOKEN_BITWISE_NOT,
		TOKEN_BITWISE_XOR,
		TOKEN_EQUALS,
		TOKEN_NOT_EQUALS,		
		TOKEN_LESS_OR_EQUAL,
		TOKEN_GREATER_OR_EQUAL,
		TOKEN_LESS_THAN,
		TOKEN_GREATER_THAN,
		TOKEN_SINGLE_ARROW,
		TOKEN_DOUBLE_ARROW,
		TOKEN_OPTION,
		TOKEN_QUESTION,
		TOKEN_ASSIGN,
		TOKEN_BECOME_ASSIGN,
		TOKEN_ADD_ASSIGN,
		TOKEN_SUBTRACT_ASSIGN,
		TOKEN_MULTIPLY_ASSIGN,
		TOKEN_DIVIDE_ASSIGN,
		TOKEN_MODULUS_ASSIGN,
		TOKEN_LSHIFT_ASSIGN,
		TOKEN_RSHIFT_ASSIGN,
		TOKEN_BITAND_ASSIGN,
		TOKEN_BITOR_ASSIGN,
		TOKEN_BITXOR_ASSIGN,
		TOKEN_MODULUS,
		TOKEN_SLASH,
		TOKEN_ASTERISK,
		TOKEN_PLUS,
		TOKEN_MINUS,
		TOKEN_POW,
		TOKEN_INTEGER_LITERAL,
		TOKEN_FLOAT_LITERAL,
		TOKEN_HEXADECIMAL_LITERAL,
		TOKEN_BINARY_LITERAL,
		TOKEN_OCTAL_LITERAL,
		TOKEN_CHAR_LITERAL,
		TOKEN_STRING_LITERAL,
		TOKEN_SCOPE,

		TOKEN_KEYWORD_BREAK,
		TOKEN_KEYWORD_CASE,
		TOKEN_KEYWORD_CONTINUE,
		TOKEN_KEYWORD_ELSE,
		TOKEN_KEYWORD_ENUM,
		TOKEN_KEYWORD_EXPORT,
		TOKEN_KEYWORD_FALSE,
		TOKEN_KEYWORD_FOR,
		TOKEN_KEYWORD_FUNCTION,
		TOKEN_KEYWORD_IF,
		TOKEN_KEYWORD_IMPORT,
		TOKEN_KEYWORD_LOOP,
		TOKEN_KEYWORD_MATCH,
		TOKEN_KEYWORD_MUT,
		TOKEN_KEYWORD_PRIVATE,
		TOKEN_KEYWORD_PUBLIC,
		TOKEN_KEYWORD_RETURN,
		TOKEN_KEYWORD_STRUCT,
		TOKEN_KEYWORD_THEN,
		TOKEN_KEYWORD_TRUE,
		TOKEN_KEYWORD_TYPE,
		TOKEN_KEYWORD_UNION,
		TOKEN_KEYWORD_VAR,
		TOKEN_KEYWORD_WHILE,
	};

	class Token
	{
	private:

		source::Location _location;
		TokenType _type;

	public:

		Token(const source::Location& location, TokenType type);

		source::Snippet get_snippet() const { return _location.get_snippet(); }
		String get_string() const { return _location.get_string(); }

		bool is_keyword();

		const source::Location& location() const { return _location; }
		TokenType type() const { return _type; }
	};

	typedef Array<Token>::const_iterator TokenIterator;
}

#endif
