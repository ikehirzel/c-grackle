# To Do

## Short Term
- GlobalFunctionTable and BlockFunctionTable? I want to be able to test block function table against just a straight function symboltable
- Better handling of declaration functions being allowed without them being valid so that the symbols can be resolved without the prototype or the body being validated
- Prototype validation separate from body validation so that they can be validated first. Something similar will need to be done for struct members 
- Operators between convertible types. (This may require grouping conversions by type) or having a Table<Type, Array<Conversion>> in symbolTable
- The rest of the binary expressions
- The rest of the assignments
- Break statement
- Continue statement
- Function calls
- intrinsic print function
- type casting
- Unary expressions
- while loops

## Longer Term
- Structs
- Constructors
- Destructors
- Struct properties
- Replaceable symbols for intrinsic functions that were generated by default
- Default parameters
- Unit testing
- Documentation

## Long Term
- Templates
- Compiled macros
- Tuples
- default not impemented exception if body is a semicolon
- User defined conversion
- exceptions
- Arena for new operations and cleanup
- Add some kind of table to each backend that allows fast generation of intrinsic operators/functions
- multi module compilation
- Named arguments
- Methods for primitives
- interfaces
- variadic functions that use param array (handle with variable length array?)
- validation of unsafe operations
- Optimization of operations between literals
- Warning for unused variables/parameters
- Warning for unused values from function returns
- Borrow checking lmao
- Disallowing the use of moved (made invalid by move) structs
- Range checking for arrays

## End Goals
- C Generation
- LLVM Backend
- WASM Backend
